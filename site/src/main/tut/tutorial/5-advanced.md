---
layout: docs
title:  "Advanced Topics on Quasiquotes and Rewriting"
section: "tutorial"
subposition: 5
---

# Advanced Topics on Quasiquotes and Rewriting

```tut:invisible
import example.doc.IR
import IR.Predef._
import IR.Quasicodes._
```

## Definitions and Recursive Functions

Squid quasiquotes are for expressions; they do not directly support definitions.
However, quasiquotes can very well refer to definitions defined outside of them (as long as these can be accessed via a static path).

For example, this is invalid and triggers an embedding error:

```tut:fail
code {
  def f(i: Int) = 2 * i; // NOT SUPPORTED!
  f(42)
}
```

However, this works:

```tut
code {
  val f = (i: Int) => 2 * i;
  f(42)
}
```

Recursive functions and lazy values are not supported, but you can emulate them using a fixpoint combinator and the `squid.utils.Lazy` data type.
As an example, we will define the factorial function.
We first define a Y combinator. 

```scala
package example.doc
object FixPoint {
  def Y[S,T](f: (S => T) => (S => T)): (S => T) = f(Y(f))(_:S)
}
```

<!-- // TODO use by-name version of Y -->

(Again, object `FixPoint` needs a static path to be accessible from quasiquotes, 
so it has to be defined in a file of its own, not in the REPL.)  
Now we can define a factorial function in a quasiquote:

```tut:invisible
import example.doc.FixPoint
```

```tut:book:silent
val factorial = code {
  FixPoint.Y[Int, Int] {
    (f: (Int => Int)) =>
      (n: Int) =>
        if (n <= 1) 1
        else n * f(n - 1)
  }
}
```

In addition,
method definitions that live in an object or a class annotated with `@embed` 
have automatic support for inlining,
as explained in the
[documentation on lowering transformers](https://github.com/epfldata/squid/blob/master/doc/Transformers.md#lowering-transformers).






<!-- 

## Sequential Rewritings

[TODO]

```scala
  case code"val arr = new collection.mutable.ArrayBuffer[$t]($v); arr.clear; arr" =>
       code"new collection.mutable.ArrayBuffer[$t]()"
```
 -->
 
 


## Speculative Rewrite Rules

It is possible to define rewrite rules that try to apply some transformations,
but abort in the middle if it turns out that these transformations cannot be carry out completely.

For this, one uses the `Abort()` construct, which throws an exception that will be caught by the innermost rewriting.

A typical application of speculative rewrite rules is the rewriting of some let-bound construct that is used in a specific way, aborting if the construct is used in unexpected ways.
For example, the following tries to rewrite any `Array[(Int,Int)]` into two `Array[Int]`,
assuming that the original array `arr` is only used in expressions of the form 
`arr.length`,
`arr(i)._1`,
`arr(i)._2` and
`arr(i) = (x,y)`.

```tut:silent
def rewriteArrayOfTuples[T,C](pgrm: Code[T,C]) = pgrm rewrite {
    case code"val $arr = new Array[(Int,Int)]($len); $body: $bt" =>
      val a, b = Variable[Array[Int]]
      
      val body0 = body rewrite {
        case code"$$arr.length" => len
        //        ^ double dollar inserts an existing term into a pattern
        case code"$$arr($i)._1" => code"$a($i)"
        case code"$$arr($i)._2" => code"$b($i)"
        case code"$$arr($i) = ($x:Int,$y:Int)" => code"$a($i) = $x; $b($i) = $y"
      }
      
      // abort if there are still `arr` free variables left in `body0`:
      val body1 = body0.subs(arr) ~> Abort()
      // note that 'subs' lazily evaluates its right-hand side argument!
      
      // reconstruct the final program:
      code"val $a = new Array[Int]($len); val $b = new Array[Int]($len); $body1"
}
```

And here is a transformation example:

```tut
rewriteArrayOfTuples(code{
  val l = readInt
  val xs = new Array[(Int,Int)](l)
  var i = 0
  while(i < xs.length) {
    xs(i) = (i,i+1)
    i += 1
  }
  val idx = new scala.util.Random().nextInt(xs.length)
  xs(idx)._1 + xs(idx)._2
})
```


## Nested Code Quotations

As an interesting aside, note that quasiquotes and quasicode can be nested:

```tut
val a = code{code{1.toDouble}}  // also written:  code""" code"1.toDouble" """
val b = a.compile
val c = b.compile
```

Notice how the printing of result `a` exposes Squid internals
â€• what is shown there corresponds to the code generated by the inner Squid quasiquote in order to build a runtime term representation for `1.toDouble`. 
This code is captured and embedded by the outer quotation.

**Note:** In order to make the code above work,
your `IR` object cannot be a local value, such as one defined within the REPL.
To run the code above in the REPL, define that object (`object IR extends SimpleAST`) in a Scala file first and then run the REPL from an SBT prompt.

More generally, if you want to be able to refer to a definition (class, method or object) 
from within a quasiquote,
this definition needs to be accessible via a static path 
(such as `my.package.MyObject.MyClass.foo`).





