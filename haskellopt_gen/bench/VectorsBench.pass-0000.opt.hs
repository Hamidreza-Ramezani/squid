-- Generated Haskell code from Graph optimizer
-- Core obtained from: The Glorious Glasgow Haskell Compilation System, version 8.6.3
-- Optimized after GHC phase:
--   desugar
-- Total nodes: 4216; Boxes: 524; Branches: 282
-- Apps: 1360; Lams: 60; Unreduced Redexes: 0

{-# LANGUAGE UnboxedTuples #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE NoMonomorphismRestriction  #-}

module Main (prod_12,test_12,test_8,test_3,prod_5,test_4,test_11,prod_1,test_7,prod_6,main,test_5,prod_2,prod_7,prod_3,test_1,prod_11,test_6,test_10,test_2,test_9,prod_8,prod_9,prod_4,prod_10) where

import Control.Exception.Base
import Criterion.Main
import Criterion.Measurement.Types
import Data.Foldable
import GHC.Base
import GHC.CString
import GHC.Enum
import GHC.Num
import GHC.Real
import GHC.TopHandler

main = (GHC.TopHandler.runMainIO (Criterion.Main.defaultMain (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "1"#))) ((Criterion.Measurement.Types.whnf test_1) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "2"#))) ((Criterion.Measurement.Types.whnf test_2) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "3"#))) ((Criterion.Measurement.Types.whnf test_3) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "4"#))) ((Criterion.Measurement.Types.whnf test_4) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "5"#))) ((Criterion.Measurement.Types.whnf test_5) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "6"#))) ((Criterion.Measurement.Types.whnf test_6) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "7"#))) ((Criterion.Measurement.Types.whnf test_7) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "8"#))) ((Criterion.Measurement.Types.whnf test_8) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "9"#))) ((Criterion.Measurement.Types.whnf test_9) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "10"#))) ((Criterion.Measurement.Types.whnf test_10) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "11"#))) ((Criterion.Measurement.Types.whnf test_11) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "12"#))) ((Criterion.Measurement.Types.whnf test_12) 1000))) []))))))))))))))

test_1 = (\n -> (Data.Foldable.sum (GHC.Base.build (\c -> (\n' -> (((GHC.Base.foldr (((GHC.Base..) c) (\i -> (_0 (((GHC.Real.^) i) 0))))) n') ((GHC.Enum.enumFromTo (GHC.Num.fromInteger 0)) n)))))))

test_2 = (\n'2 -> (Data.Foldable.sum (GHC.Base.build (\c' -> (\n'3 -> (((GHC.Base.foldr (((GHC.Base..) c') (\i' -> let sh = ((GHC.Real.^) i') in (_1 (sh 0) (sh 1))))) n'3) ((GHC.Enum.enumFromTo (GHC.Num.fromInteger 0)) n'2)))))))

test_3 = (\n'4 -> (Data.Foldable.sum (GHC.Base.build (\c'2 -> (\n'5 -> (((GHC.Base.foldr (((GHC.Base..) c'2) (\i'2 -> let sh' = ((GHC.Real.^) i'2) in (_2 (sh' 0) (sh' 1) (sh' 2))))) n'5) ((GHC.Enum.enumFromTo (GHC.Num.fromInteger 0)) n'4)))))))

test_4 = (\n'6 -> (Data.Foldable.sum (GHC.Base.build (\c'3 -> (\n'7 -> (((GHC.Base.foldr (((GHC.Base..) c'3) (\i'3 -> let sh'2 = ((GHC.Real.^) i'3) in (_3 (sh'2 0) (sh'2 1) (sh'2 2) (sh'2 3))))) n'7) ((GHC.Enum.enumFromTo (GHC.Num.fromInteger 0)) n'6)))))))

test_5 = (\n'8 -> (Data.Foldable.sum (GHC.Base.build (\c'4 -> (\n'9 -> (((GHC.Base.foldr (((GHC.Base..) c'4) (\i'4 -> let sh'3 = ((GHC.Real.^) i'4) in (_4 (sh'3 0) (sh'3 1) (sh'3 2) (sh'3 3) (sh'3 4))))) n'9) ((GHC.Enum.enumFromTo (GHC.Num.fromInteger 0)) n'8)))))))

test_6 = (\n'10 -> (Data.Foldable.sum (GHC.Base.build (\c'5 -> (\n'11 -> (((GHC.Base.foldr (((GHC.Base..) c'5) (\i'5 -> let sh'4 = ((GHC.Real.^) i'5) in (_5 (sh'4 0) (sh'4 1) (sh'4 2) (sh'4 3) (sh'4 4) (sh'4 5))))) n'11) ((GHC.Enum.enumFromTo (GHC.Num.fromInteger 0)) n'10)))))))

test_7 = (\n'12 -> (Data.Foldable.sum (GHC.Base.build (\c'6 -> (\n'13 -> (((GHC.Base.foldr (((GHC.Base..) c'6) (\i'6 -> let sh'5 = ((GHC.Real.^) i'6) in (_6 (sh'5 0) (sh'5 1) (sh'5 2) (sh'5 3) (sh'5 4) (sh'5 5) (sh'5 6))))) n'13) ((GHC.Enum.enumFromTo (GHC.Num.fromInteger 0)) n'12)))))))

test_8 = (\n'14 -> (Data.Foldable.sum (GHC.Base.build (\c'7 -> (\n'15 -> (((GHC.Base.foldr (((GHC.Base..) c'7) (\i'7 -> let sh'6 = ((GHC.Real.^) i'7) in (_7 (sh'6 0) (sh'6 1) (sh'6 2) (sh'6 3) (sh'6 4) (sh'6 5) (sh'6 6) (sh'6 7))))) n'15) ((GHC.Enum.enumFromTo (GHC.Num.fromInteger 0)) n'14)))))))

test_9 = (\n'16 -> (Data.Foldable.sum (GHC.Base.build (\c'8 -> (\n'17 -> (((GHC.Base.foldr (((GHC.Base..) c'8) (\i'8 -> let sh'7 = ((GHC.Real.^) i'8) in (_8 (sh'7 0) (sh'7 1) (sh'7 2) (sh'7 3) (sh'7 4) (sh'7 5) (sh'7 6) (sh'7 7) (sh'7 8))))) n'17) ((GHC.Enum.enumFromTo (GHC.Num.fromInteger 0)) n'16)))))))

test_10 = (\n'18 -> (Data.Foldable.sum (GHC.Base.build (\c'9 -> (\n'19 -> (((GHC.Base.foldr (((GHC.Base..) c'9) (\i'9 -> let sh'8 = ((GHC.Real.^) i'9) in (_9 (sh'8 0) (sh'8 1) (sh'8 2) (sh'8 3) (sh'8 4) (sh'8 5) (sh'8 6) (sh'8 7) (sh'8 8) (sh'8 9))))) n'19) ((GHC.Enum.enumFromTo (GHC.Num.fromInteger 0)) n'18)))))))

test_11 = (\n'20 -> (Data.Foldable.sum (GHC.Base.build (\c'10 -> (\n'21 -> (((GHC.Base.foldr (((GHC.Base..) c'10) (\i'10 -> let sh'9 = ((GHC.Real.^) i'10) in (_10 (sh'9 0) (sh'9 1) (sh'9 2) (sh'9 3) (sh'9 4) (sh'9 5) (sh'9 6) (sh'9 7) (sh'9 8) (sh'9 9) (sh'9 10))))) n'21) ((GHC.Enum.enumFromTo (GHC.Num.fromInteger 0)) n'20)))))))

test_12 = (\n'22 -> (Data.Foldable.sum (GHC.Base.build (\c'11 -> (\n'23 -> (((GHC.Base.foldr (((GHC.Base..) c'11) (\i'11 -> let sh'10 = ((GHC.Real.^) i'11) in (_11 (sh'10 0) (sh'10 1) (sh'10 2) (sh'10 3) (sh'10 4) (sh'10 5) (sh'10 6) (sh'10 7) (sh'10 8) (sh'10 9) (sh'10 10) (sh'10 11))))) n'23) ((GHC.Enum.enumFromTo (GHC.Num.fromInteger 0)) n'22)))))))

prod_1 = (\ds -> (case ds of {[] -> (GHC.Num.fromInteger 1); (:) arg0 arg1 -> (case arg1 of {[] -> (_0 arg0); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(8,1)-(9,13)|function prod_1"#)})}))

_0 ds' = (((GHC.Num.*) (GHC.Num.fromInteger 1)) ds')

prod_10 = (\ds'2 -> let { sh'12 = ((GHC.Num.*) sh'11); sh'11 = (GHC.Num.fromInteger 1) } in (case ds'2 of {[] -> sh'11; (:) arg0' arg1' -> (case arg1' of {[] -> (sh'12 arg0'); (:) arg0'2 arg1'2 -> (case arg1'2 of {[] -> (((GHC.Num.*) (sh'12 arg0')) arg0'2); (:) arg0'3 arg1'3 -> (case arg1'3 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (sh'12 arg0')) arg0'2)) arg0'3); (:) arg0'4 arg1'4 -> (case arg1'4 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'12 arg0')) arg0'2)) arg0'3)) arg0'4); (:) arg0'5 arg1'5 -> (case arg1'5 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'12 arg0')) arg0'2)) arg0'3)) arg0'4)) arg0'5); (:) arg0'6 arg1'6 -> (case arg1'6 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'12 arg0')) arg0'2)) arg0'3)) arg0'4)) arg0'5)) arg0'6); (:) arg0'7 arg1'7 -> (case arg1'7 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'12 arg0')) arg0'2)) arg0'3)) arg0'4)) arg0'5)) arg0'6)) arg0'7); (:) arg0'8 arg1'8 -> (case arg1'8 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'12 arg0')) arg0'2)) arg0'3)) arg0'4)) arg0'5)) arg0'6)) arg0'7)) arg0'8); (:) arg0'9 arg1'9 -> (case arg1'9 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'12 arg0')) arg0'2)) arg0'3)) arg0'4)) arg0'5)) arg0'6)) arg0'7)) arg0'8)) arg0'9); (:) arg0'10 arg1'10 -> (case arg1'10 of {[] -> (_9 arg0' arg0'2 arg0'3 arg0'4 arg0'5 arg0'6 arg0'7 arg0'8 arg0'9 arg0'10); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(89,1)-(99,14)|function prod_10"#)})})})})})})})})})})}))

_9 ds'3 ds'4 ds'5 ds'6 ds'7 ds'8 ds'9 ds'10 ds'11 ds'12 = (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (GHC.Num.fromInteger 1)) ds'3)) ds'4)) ds'5)) ds'6)) ds'7)) ds'8)) ds'9)) ds'10)) ds'11)) ds'12)

prod_11 = (\ds'13 -> let { sh'14 = ((GHC.Num.*) sh'13); sh'13 = (GHC.Num.fromInteger 1) } in (case ds'13 of {[] -> sh'13; (:) arg0'11 arg1'11 -> (case arg1'11 of {[] -> (sh'14 arg0'11); (:) arg0'12 arg1'12 -> (case arg1'12 of {[] -> (((GHC.Num.*) (sh'14 arg0'11)) arg0'12); (:) arg0'13 arg1'13 -> (case arg1'13 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (sh'14 arg0'11)) arg0'12)) arg0'13); (:) arg0'14 arg1'14 -> (case arg1'14 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'14 arg0'11)) arg0'12)) arg0'13)) arg0'14); (:) arg0'15 arg1'15 -> (case arg1'15 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'14 arg0'11)) arg0'12)) arg0'13)) arg0'14)) arg0'15); (:) arg0'16 arg1'16 -> (case arg1'16 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'14 arg0'11)) arg0'12)) arg0'13)) arg0'14)) arg0'15)) arg0'16); (:) arg0'17 arg1'17 -> (case arg1'17 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'14 arg0'11)) arg0'12)) arg0'13)) arg0'14)) arg0'15)) arg0'16)) arg0'17); (:) arg0'18 arg1'18 -> (case arg1'18 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'14 arg0'11)) arg0'12)) arg0'13)) arg0'14)) arg0'15)) arg0'16)) arg0'17)) arg0'18); (:) arg0'19 arg1'19 -> (case arg1'19 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'14 arg0'11)) arg0'12)) arg0'13)) arg0'14)) arg0'15)) arg0'16)) arg0'17)) arg0'18)) arg0'19); (:) arg0'20 arg1'20 -> (case arg1'20 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'14 arg0'11)) arg0'12)) arg0'13)) arg0'14)) arg0'15)) arg0'16)) arg0'17)) arg0'18)) arg0'19)) arg0'20); (:) arg0'21 arg1'21 -> (case arg1'21 of {[] -> (_10 arg0'11 arg0'12 arg0'13 arg0'14 arg0'15 arg0'16 arg0'17 arg0'18 arg0'19 arg0'20 arg0'21); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(103,1)-(114,14)|function prod_11"#)})})})})})})})})})})})}))

_10 ds'14 ds'15 ds'16 ds'17 ds'18 ds'19 ds'20 ds'21 ds'22 ds'23 ds'24 = (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (GHC.Num.fromInteger 1)) ds'14)) ds'15)) ds'16)) ds'17)) ds'18)) ds'19)) ds'20)) ds'21)) ds'22)) ds'23)) ds'24)

prod_12 = (\ds'25 -> let { sh'16 = ((GHC.Num.*) sh'15); sh'15 = (GHC.Num.fromInteger 1) } in (case ds'25 of {[] -> sh'15; (:) arg0'22 arg1'22 -> (case arg1'22 of {[] -> (sh'16 arg0'22); (:) arg0'23 arg1'23 -> (case arg1'23 of {[] -> (((GHC.Num.*) (sh'16 arg0'22)) arg0'23); (:) arg0'24 arg1'24 -> (case arg1'24 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (sh'16 arg0'22)) arg0'23)) arg0'24); (:) arg0'25 arg1'25 -> (case arg1'25 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'16 arg0'22)) arg0'23)) arg0'24)) arg0'25); (:) arg0'26 arg1'26 -> (case arg1'26 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'16 arg0'22)) arg0'23)) arg0'24)) arg0'25)) arg0'26); (:) arg0'27 arg1'27 -> (case arg1'27 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'16 arg0'22)) arg0'23)) arg0'24)) arg0'25)) arg0'26)) arg0'27); (:) arg0'28 arg1'28 -> (case arg1'28 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'16 arg0'22)) arg0'23)) arg0'24)) arg0'25)) arg0'26)) arg0'27)) arg0'28); (:) arg0'29 arg1'29 -> (case arg1'29 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'16 arg0'22)) arg0'23)) arg0'24)) arg0'25)) arg0'26)) arg0'27)) arg0'28)) arg0'29); (:) arg0'30 arg1'30 -> (case arg1'30 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'16 arg0'22)) arg0'23)) arg0'24)) arg0'25)) arg0'26)) arg0'27)) arg0'28)) arg0'29)) arg0'30); (:) arg0'31 arg1'31 -> (case arg1'31 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'16 arg0'22)) arg0'23)) arg0'24)) arg0'25)) arg0'26)) arg0'27)) arg0'28)) arg0'29)) arg0'30)) arg0'31); (:) arg0'32 arg1'32 -> (case arg1'32 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'16 arg0'22)) arg0'23)) arg0'24)) arg0'25)) arg0'26)) arg0'27)) arg0'28)) arg0'29)) arg0'30)) arg0'31)) arg0'32); (:) arg0'33 arg1'33 -> (case arg1'33 of {[] -> (_11 arg0'22 arg0'23 arg0'24 arg0'25 arg0'26 arg0'27 arg0'28 arg0'29 arg0'30 arg0'31 arg0'32 arg0'33); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(118,1)-(130,14)|function prod_12"#)})})})})})})})})})})})})}))

_11 ds'26 ds'27 ds'28 ds'29 ds'30 ds'31 ds'32 ds'33 ds'34 ds'35 ds'36 ds'37 = (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (GHC.Num.fromInteger 1)) ds'26)) ds'27)) ds'28)) ds'29)) ds'30)) ds'31)) ds'32)) ds'33)) ds'34)) ds'35)) ds'36)) ds'37)

prod_2 = (\ds'38 -> let sh'17 = (GHC.Num.fromInteger 1) in (case ds'38 of {[] -> sh'17; (:) arg0'34 arg1'34 -> (case arg1'34 of {[] -> (((GHC.Num.*) sh'17) arg0'34); (:) arg0'35 arg1'35 -> (case arg1'35 of {[] -> (_1 arg0'34 arg0'35); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(13,1)-(15,13)|function prod_2"#)})})}))

_1 ds'39 ds'40 = (((GHC.Num.*) (((GHC.Num.*) (GHC.Num.fromInteger 1)) ds'39)) ds'40)

prod_3 = (\ds'41 -> let { sh'19 = ((GHC.Num.*) sh'18); sh'18 = (GHC.Num.fromInteger 1) } in (case ds'41 of {[] -> sh'18; (:) arg0'36 arg1'36 -> (case arg1'36 of {[] -> (sh'19 arg0'36); (:) arg0'37 arg1'37 -> (case arg1'37 of {[] -> (((GHC.Num.*) (sh'19 arg0'36)) arg0'37); (:) arg0'38 arg1'38 -> (case arg1'38 of {[] -> (_2 arg0'36 arg0'37 arg0'38); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(19,1)-(22,13)|function prod_3"#)})})})}))

_2 ds'42 ds'43 ds'44 = (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (GHC.Num.fromInteger 1)) ds'42)) ds'43)) ds'44)

prod_4 = (\ds'45 -> let { sh'21 = ((GHC.Num.*) sh'20); sh'20 = (GHC.Num.fromInteger 1) } in (case ds'45 of {[] -> sh'20; (:) arg0'39 arg1'39 -> (case arg1'39 of {[] -> (sh'21 arg0'39); (:) arg0'40 arg1'40 -> (case arg1'40 of {[] -> (((GHC.Num.*) (sh'21 arg0'39)) arg0'40); (:) arg0'41 arg1'41 -> (case arg1'41 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (sh'21 arg0'39)) arg0'40)) arg0'41); (:) arg0'42 arg1'42 -> (case arg1'42 of {[] -> (_3 arg0'39 arg0'40 arg0'41 arg0'42); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(26,1)-(30,13)|function prod_4"#)})})})})}))

_3 ds'46 ds'47 ds'48 ds'49 = (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (GHC.Num.fromInteger 1)) ds'46)) ds'47)) ds'48)) ds'49)

prod_5 = (\ds'50 -> let { sh'23 = ((GHC.Num.*) sh'22); sh'22 = (GHC.Num.fromInteger 1) } in (case ds'50 of {[] -> sh'22; (:) arg0'43 arg1'43 -> (case arg1'43 of {[] -> (sh'23 arg0'43); (:) arg0'44 arg1'44 -> (case arg1'44 of {[] -> (((GHC.Num.*) (sh'23 arg0'43)) arg0'44); (:) arg0'45 arg1'45 -> (case arg1'45 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (sh'23 arg0'43)) arg0'44)) arg0'45); (:) arg0'46 arg1'46 -> (case arg1'46 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'23 arg0'43)) arg0'44)) arg0'45)) arg0'46); (:) arg0'47 arg1'47 -> (case arg1'47 of {[] -> (_4 arg0'43 arg0'44 arg0'45 arg0'46 arg0'47); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(34,1)-(39,13)|function prod_5"#)})})})})})}))

_4 ds'51 ds'52 ds'53 ds'54 ds'55 = (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (GHC.Num.fromInteger 1)) ds'51)) ds'52)) ds'53)) ds'54)) ds'55)

prod_6 = (\ds'56 -> let { sh'25 = ((GHC.Num.*) sh'24); sh'24 = (GHC.Num.fromInteger 1) } in (case ds'56 of {[] -> sh'24; (:) arg0'48 arg1'48 -> (case arg1'48 of {[] -> (sh'25 arg0'48); (:) arg0'49 arg1'49 -> (case arg1'49 of {[] -> (((GHC.Num.*) (sh'25 arg0'48)) arg0'49); (:) arg0'50 arg1'50 -> (case arg1'50 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (sh'25 arg0'48)) arg0'49)) arg0'50); (:) arg0'51 arg1'51 -> (case arg1'51 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'25 arg0'48)) arg0'49)) arg0'50)) arg0'51); (:) arg0'52 arg1'52 -> (case arg1'52 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'25 arg0'48)) arg0'49)) arg0'50)) arg0'51)) arg0'52); (:) arg0'53 arg1'53 -> (case arg1'53 of {[] -> (_5 arg0'48 arg0'49 arg0'50 arg0'51 arg0'52 arg0'53); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(43,1)-(49,13)|function prod_6"#)})})})})})})}))

_5 ds'57 ds'58 ds'59 ds'60 ds'61 ds'62 = (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (GHC.Num.fromInteger 1)) ds'57)) ds'58)) ds'59)) ds'60)) ds'61)) ds'62)

prod_7 = (\ds'63 -> let { sh'27 = ((GHC.Num.*) sh'26); sh'26 = (GHC.Num.fromInteger 1) } in (case ds'63 of {[] -> sh'26; (:) arg0'54 arg1'54 -> (case arg1'54 of {[] -> (sh'27 arg0'54); (:) arg0'55 arg1'55 -> (case arg1'55 of {[] -> (((GHC.Num.*) (sh'27 arg0'54)) arg0'55); (:) arg0'56 arg1'56 -> (case arg1'56 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (sh'27 arg0'54)) arg0'55)) arg0'56); (:) arg0'57 arg1'57 -> (case arg1'57 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'27 arg0'54)) arg0'55)) arg0'56)) arg0'57); (:) arg0'58 arg1'58 -> (case arg1'58 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'27 arg0'54)) arg0'55)) arg0'56)) arg0'57)) arg0'58); (:) arg0'59 arg1'59 -> (case arg1'59 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'27 arg0'54)) arg0'55)) arg0'56)) arg0'57)) arg0'58)) arg0'59); (:) arg0'60 arg1'60 -> (case arg1'60 of {[] -> (_6 arg0'54 arg0'55 arg0'56 arg0'57 arg0'58 arg0'59 arg0'60); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(53,1)-(60,13)|function prod_7"#)})})})})})})})}))

_6 ds'64 ds'65 ds'66 ds'67 ds'68 ds'69 ds'70 = (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (GHC.Num.fromInteger 1)) ds'64)) ds'65)) ds'66)) ds'67)) ds'68)) ds'69)) ds'70)

prod_8 = (\ds'71 -> let { sh'29 = ((GHC.Num.*) sh'28); sh'28 = (GHC.Num.fromInteger 1) } in (case ds'71 of {[] -> sh'28; (:) arg0'61 arg1'61 -> (case arg1'61 of {[] -> (sh'29 arg0'61); (:) arg0'62 arg1'62 -> (case arg1'62 of {[] -> (((GHC.Num.*) (sh'29 arg0'61)) arg0'62); (:) arg0'63 arg1'63 -> (case arg1'63 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (sh'29 arg0'61)) arg0'62)) arg0'63); (:) arg0'64 arg1'64 -> (case arg1'64 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'29 arg0'61)) arg0'62)) arg0'63)) arg0'64); (:) arg0'65 arg1'65 -> (case arg1'65 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'29 arg0'61)) arg0'62)) arg0'63)) arg0'64)) arg0'65); (:) arg0'66 arg1'66 -> (case arg1'66 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'29 arg0'61)) arg0'62)) arg0'63)) arg0'64)) arg0'65)) arg0'66); (:) arg0'67 arg1'67 -> (case arg1'67 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'29 arg0'61)) arg0'62)) arg0'63)) arg0'64)) arg0'65)) arg0'66)) arg0'67); (:) arg0'68 arg1'68 -> (case arg1'68 of {[] -> (_7 arg0'61 arg0'62 arg0'63 arg0'64 arg0'65 arg0'66 arg0'67 arg0'68); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(64,1)-(72,13)|function prod_8"#)})})})})})})})})}))

_7 ds'72 ds'73 ds'74 ds'75 ds'76 ds'77 ds'78 ds'79 = (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (GHC.Num.fromInteger 1)) ds'72)) ds'73)) ds'74)) ds'75)) ds'76)) ds'77)) ds'78)) ds'79)

prod_9 = (\ds'80 -> let { sh'31 = ((GHC.Num.*) sh'30); sh'30 = (GHC.Num.fromInteger 1) } in (case ds'80 of {[] -> sh'30; (:) arg0'69 arg1'69 -> (case arg1'69 of {[] -> (sh'31 arg0'69); (:) arg0'70 arg1'70 -> (case arg1'70 of {[] -> (((GHC.Num.*) (sh'31 arg0'69)) arg0'70); (:) arg0'71 arg1'71 -> (case arg1'71 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (sh'31 arg0'69)) arg0'70)) arg0'71); (:) arg0'72 arg1'72 -> (case arg1'72 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'31 arg0'69)) arg0'70)) arg0'71)) arg0'72); (:) arg0'73 arg1'73 -> (case arg1'73 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'31 arg0'69)) arg0'70)) arg0'71)) arg0'72)) arg0'73); (:) arg0'74 arg1'74 -> (case arg1'74 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'31 arg0'69)) arg0'70)) arg0'71)) arg0'72)) arg0'73)) arg0'74); (:) arg0'75 arg1'75 -> (case arg1'75 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'31 arg0'69)) arg0'70)) arg0'71)) arg0'72)) arg0'73)) arg0'74)) arg0'75); (:) arg0'76 arg1'76 -> (case arg1'76 of {[] -> (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (sh'31 arg0'69)) arg0'70)) arg0'71)) arg0'72)) arg0'73)) arg0'74)) arg0'75)) arg0'76); (:) arg0'77 arg1'77 -> (case arg1'77 of {[] -> (_8 arg0'69 arg0'70 arg0'71 arg0'72 arg0'73 arg0'74 arg0'75 arg0'76 arg0'77); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(76,1)-(85,13)|function prod_9"#)})})})})})})})})})}))

_8 ds'81 ds'82 ds'83 ds'84 ds'85 ds'86 ds'87 ds'88 ds'89 = (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (((GHC.Num.*) (GHC.Num.fromInteger 1)) ds'81)) ds'82)) ds'83)) ds'84)) ds'85)) ds'86)) ds'87)) ds'88)) ds'89)
