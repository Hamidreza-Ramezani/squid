-- Generated Haskell code from Graph optimizer
-- Core obtained from: The Glorious Glasgow Haskell Compilation System, version 8.6.3
-- Optimized after GHC phase:
--   desugar
-- Total nodes: 3075; Boxes: 377; Branches: 205
-- Apps: 972; Lams: 50; Unreduced Redexes: 0

{-# LANGUAGE UnboxedTuples #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE NoMonomorphismRestriction  #-}

module Main (prod_5,prod_1,prod_6,main,prod_2,prod_7,prod_3,prod_8,prod_9,prod_4,prod_10) where

import Control.Exception.Base
import Criterion.Main
import Criterion.Measurement.Types
import Data.Foldable
import GHC.Base
import GHC.CString
import GHC.Enum
import GHC.Num
import GHC.TopHandler

main = (let { sh = (GHC.Num.fromInteger 6); sh'5 = (GHC.Num.fromInteger 2); sh'16 = (GHC.Num.fromInteger 8); sh' = (GHC.Num.fromInteger 0); sh'7 = (GHC.Num.fromInteger 3); sh'3 = (GHC.Num.fromInteger 1); sh'14 = (GHC.Num.fromInteger 7); sh'11 = (GHC.Num.fromInteger 5); sh'9 = (GHC.Num.fromInteger 4) } in (GHC.TopHandler.runMainIO (Criterion.Main.defaultMain (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "1"#))) ((Criterion.Measurement.Types.whnf (\n -> (Data.Foldable.sum (GHC.Base.build (\c -> (\n' -> (((GHC.Base.foldr (((GHC.Base..) c) (\i -> (_0 (((GHC.Num.+) i) sh'))))) n') ((GHC.Enum.enumFromTo sh') n)))))))) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "2"#))) ((Criterion.Measurement.Types.whnf (\n'2 -> (Data.Foldable.sum (GHC.Base.build (\c' -> (\n'3 -> (((GHC.Base.foldr (((GHC.Base..) c') (\i' -> let sh'2 = ((GHC.Num.+) i') in (_1 (sh'2 sh') (sh'2 sh'3))))) n'3) ((GHC.Enum.enumFromTo sh') n'2)))))))) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "3"#))) ((Criterion.Measurement.Types.whnf (\n'4 -> (Data.Foldable.sum (GHC.Base.build (\c'2 -> (\n'5 -> (((GHC.Base.foldr (((GHC.Base..) c'2) (\i'2 -> let sh'4 = ((GHC.Num.+) i'2) in (_2 (sh'4 sh') (sh'4 sh'3) (sh'4 sh'5))))) n'5) ((GHC.Enum.enumFromTo sh') n'4)))))))) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "4"#))) ((Criterion.Measurement.Types.whnf (\n'6 -> (Data.Foldable.sum (GHC.Base.build (\c'3 -> (\n'7 -> (((GHC.Base.foldr (((GHC.Base..) c'3) (\i'3 -> let sh'6 = ((GHC.Num.+) i'3) in (_3 (sh'6 sh') (sh'6 sh'3) (sh'6 sh'5) (sh'6 sh'7))))) n'7) ((GHC.Enum.enumFromTo sh') n'6)))))))) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "5"#))) ((Criterion.Measurement.Types.whnf (\n'8 -> (Data.Foldable.sum (GHC.Base.build (\c'4 -> (\n'9 -> (((GHC.Base.foldr (((GHC.Base..) c'4) (\i'4 -> let sh'8 = ((GHC.Num.+) i'4) in (_4 (sh'8 sh') (sh'8 sh'3) (sh'8 sh'5) (sh'8 sh'7) (sh'8 sh'9))))) n'9) ((GHC.Enum.enumFromTo sh') n'8)))))))) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "6"#))) ((Criterion.Measurement.Types.whnf (\n'10 -> (Data.Foldable.sum (GHC.Base.build (\c'5 -> (\n'11 -> (((GHC.Base.foldr (((GHC.Base..) c'5) (\i'5 -> let sh'10 = ((GHC.Num.+) i'5) in (_5 (sh'10 sh') (sh'10 sh'3) (sh'10 sh'5) (sh'10 sh'7) (sh'10 sh'9) (sh'10 sh'11))))) n'11) ((GHC.Enum.enumFromTo sh') n'10)))))))) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "7"#))) ((Criterion.Measurement.Types.whnf (\n'12 -> (Data.Foldable.sum (GHC.Base.build (\c'6 -> (\n'13 -> (((GHC.Base.foldr (((GHC.Base..) c'6) (\i'6 -> let sh'12 = ((GHC.Num.+) i'6) in (_6 (sh'12 sh') (sh'12 sh'3) (sh'12 sh'5) (sh'12 sh'7) (sh'12 sh'9) (sh'12 sh'11) (sh'12 sh))))) n'13) ((GHC.Enum.enumFromTo sh') n'12)))))))) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "8"#))) ((Criterion.Measurement.Types.whnf (\n'14 -> (Data.Foldable.sum (GHC.Base.build (\c'7 -> (\n'15 -> (((GHC.Base.foldr (((GHC.Base..) c'7) (\i'7 -> let sh'13 = ((GHC.Num.+) i'7) in (_7 (sh'13 sh') (sh'13 sh'3) (sh'13 sh'5) (sh'13 sh'7) (sh'13 sh'9) (sh'13 sh'11) (sh'13 sh) (sh'13 sh'14))))) n'15) ((GHC.Enum.enumFromTo sh') n'14)))))))) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "9"#))) ((Criterion.Measurement.Types.whnf (\n'16 -> (Data.Foldable.sum (GHC.Base.build (\c'8 -> (\n'17 -> (((GHC.Base.foldr (((GHC.Base..) c'8) (\i'8 -> let sh'15 = ((GHC.Num.+) i'8) in (_8 (sh'15 sh'16) (sh'15 sh') (sh'15 sh'3) (sh'15 sh'5) (sh'15 sh'7) (sh'15 sh'9) (sh'15 sh'11) (sh'15 sh) (sh'15 sh'14))))) n'17) ((GHC.Enum.enumFromTo sh') n'16)))))))) 1000))) (((:) (((GHC.Base.$) (Criterion.Measurement.Types.bench (GHC.CString.unpackCString# "10"#))) ((Criterion.Measurement.Types.whnf (\n'18 -> (Data.Foldable.sum (GHC.Base.build (\c'9 -> (\n'19 -> (((GHC.Base.foldr (((GHC.Base..) c'9) (\i'9 -> let sh'17 = ((GHC.Num.+) i'9) in (_9 (sh'17 sh') (sh'17 sh'3) (sh'17 sh'5) (sh'17 sh'7) (sh'17 sh'9) (sh'17 sh'11) (sh'17 sh) (sh'17 sh'14) (sh'17 sh'16) (sh'17 (GHC.Num.fromInteger 9)))))) n'19) ((GHC.Enum.enumFromTo sh') n'18)))))))) 1000))) [])))))))))))))

_0 ds = (((GHC.Num.+) (GHC.Num.fromInteger 0)) ds)

_1 ds' ds'2 = (((GHC.Num.+) (((GHC.Num.+) (GHC.Num.fromInteger 0)) ds')) ds'2)

_2 ds'3 ds'4 ds'5 = (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (GHC.Num.fromInteger 0)) ds'3)) ds'4)) ds'5)

_3 ds'6 ds'7 ds'8 ds'9 = (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (GHC.Num.fromInteger 0)) ds'6)) ds'7)) ds'8)) ds'9)

_4 ds'10 ds'11 ds'12 ds'13 ds'14 = (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (GHC.Num.fromInteger 0)) ds'10)) ds'11)) ds'12)) ds'13)) ds'14)

_5 ds'15 ds'16 ds'17 ds'18 ds'19 ds'20 = (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (GHC.Num.fromInteger 0)) ds'15)) ds'16)) ds'17)) ds'18)) ds'19)) ds'20)

_6 ds'21 ds'22 ds'23 ds'24 ds'25 ds'26 ds'27 = (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (GHC.Num.fromInteger 0)) ds'21)) ds'22)) ds'23)) ds'24)) ds'25)) ds'26)) ds'27)

_7 ds'28 ds'29 ds'30 ds'31 ds'32 ds'33 ds'34 ds'35 = (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (GHC.Num.fromInteger 0)) ds'28)) ds'29)) ds'30)) ds'31)) ds'32)) ds'33)) ds'34)) ds'35)

_8 ds'36 ds'37 ds'38 ds'39 ds'40 ds'41 ds'42 ds'43 ds'44 = (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (GHC.Num.fromInteger 0)) ds'37)) ds'38)) ds'39)) ds'40)) ds'41)) ds'42)) ds'43)) ds'44)) ds'36)

_9 ds'45 ds'46 ds'47 ds'48 ds'49 ds'50 ds'51 ds'52 ds'53 ds'54 = (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (GHC.Num.fromInteger 0)) ds'45)) ds'46)) ds'47)) ds'48)) ds'49)) ds'50)) ds'51)) ds'52)) ds'53)) ds'54)

prod_1 = (\ds'55 -> (case ds'55 of {[] -> (GHC.Num.fromInteger 0); (:) arg0 arg1 -> (case arg1 of {[] -> (_0 arg0); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(8,1)-(9,13)|function prod_1"#)})}))

prod_10 = (\ds'56 -> let { sh'19 = ((GHC.Num.+) sh'18); sh'18 = (GHC.Num.fromInteger 0) } in (case ds'56 of {[] -> sh'18; (:) arg0' arg1' -> (case arg1' of {[] -> (sh'19 arg0'); (:) arg0'2 arg1'2 -> (case arg1'2 of {[] -> (((GHC.Num.+) (sh'19 arg0')) arg0'2); (:) arg0'3 arg1'3 -> (case arg1'3 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (sh'19 arg0')) arg0'2)) arg0'3); (:) arg0'4 arg1'4 -> (case arg1'4 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'19 arg0')) arg0'2)) arg0'3)) arg0'4); (:) arg0'5 arg1'5 -> (case arg1'5 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'19 arg0')) arg0'2)) arg0'3)) arg0'4)) arg0'5); (:) arg0'6 arg1'6 -> (case arg1'6 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'19 arg0')) arg0'2)) arg0'3)) arg0'4)) arg0'5)) arg0'6); (:) arg0'7 arg1'7 -> (case arg1'7 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'19 arg0')) arg0'2)) arg0'3)) arg0'4)) arg0'5)) arg0'6)) arg0'7); (:) arg0'8 arg1'8 -> (case arg1'8 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'19 arg0')) arg0'2)) arg0'3)) arg0'4)) arg0'5)) arg0'6)) arg0'7)) arg0'8); (:) arg0'9 arg1'9 -> (case arg1'9 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'19 arg0')) arg0'2)) arg0'3)) arg0'4)) arg0'5)) arg0'6)) arg0'7)) arg0'8)) arg0'9); (:) arg0'10 arg1'10 -> (case arg1'10 of {[] -> (_9 arg0' arg0'2 arg0'3 arg0'4 arg0'5 arg0'6 arg0'7 arg0'8 arg0'9 arg0'10); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(89,1)-(99,14)|function prod_10"#)})})})})})})})})})})}))

prod_2 = (\ds'57 -> let sh'20 = (GHC.Num.fromInteger 0) in (case ds'57 of {[] -> sh'20; (:) arg0'11 arg1'11 -> (case arg1'11 of {[] -> (((GHC.Num.+) sh'20) arg0'11); (:) arg0'12 arg1'12 -> (case arg1'12 of {[] -> (_1 arg0'11 arg0'12); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(13,1)-(15,13)|function prod_2"#)})})}))

prod_3 = (\ds'58 -> let { sh'22 = ((GHC.Num.+) sh'21); sh'21 = (GHC.Num.fromInteger 0) } in (case ds'58 of {[] -> sh'21; (:) arg0'13 arg1'13 -> (case arg1'13 of {[] -> (sh'22 arg0'13); (:) arg0'14 arg1'14 -> (case arg1'14 of {[] -> (((GHC.Num.+) (sh'22 arg0'13)) arg0'14); (:) arg0'15 arg1'15 -> (case arg1'15 of {[] -> (_2 arg0'13 arg0'14 arg0'15); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(19,1)-(22,13)|function prod_3"#)})})})}))

prod_4 = (\ds'59 -> let { sh'24 = ((GHC.Num.+) sh'23); sh'23 = (GHC.Num.fromInteger 0) } in (case ds'59 of {[] -> sh'23; (:) arg0'16 arg1'16 -> (case arg1'16 of {[] -> (sh'24 arg0'16); (:) arg0'17 arg1'17 -> (case arg1'17 of {[] -> (((GHC.Num.+) (sh'24 arg0'16)) arg0'17); (:) arg0'18 arg1'18 -> (case arg1'18 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (sh'24 arg0'16)) arg0'17)) arg0'18); (:) arg0'19 arg1'19 -> (case arg1'19 of {[] -> (_3 arg0'16 arg0'17 arg0'18 arg0'19); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(26,1)-(30,13)|function prod_4"#)})})})})}))

prod_5 = (\ds'60 -> let { sh'26 = ((GHC.Num.+) sh'25); sh'25 = (GHC.Num.fromInteger 0) } in (case ds'60 of {[] -> sh'25; (:) arg0'20 arg1'20 -> (case arg1'20 of {[] -> (sh'26 arg0'20); (:) arg0'21 arg1'21 -> (case arg1'21 of {[] -> (((GHC.Num.+) (sh'26 arg0'20)) arg0'21); (:) arg0'22 arg1'22 -> (case arg1'22 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (sh'26 arg0'20)) arg0'21)) arg0'22); (:) arg0'23 arg1'23 -> (case arg1'23 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'26 arg0'20)) arg0'21)) arg0'22)) arg0'23); (:) arg0'24 arg1'24 -> (case arg1'24 of {[] -> (_4 arg0'20 arg0'21 arg0'22 arg0'23 arg0'24); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(34,1)-(39,13)|function prod_5"#)})})})})})}))

prod_6 = (\ds'61 -> let { sh'28 = ((GHC.Num.+) sh'27); sh'27 = (GHC.Num.fromInteger 0) } in (case ds'61 of {[] -> sh'27; (:) arg0'25 arg1'25 -> (case arg1'25 of {[] -> (sh'28 arg0'25); (:) arg0'26 arg1'26 -> (case arg1'26 of {[] -> (((GHC.Num.+) (sh'28 arg0'25)) arg0'26); (:) arg0'27 arg1'27 -> (case arg1'27 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (sh'28 arg0'25)) arg0'26)) arg0'27); (:) arg0'28 arg1'28 -> (case arg1'28 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'28 arg0'25)) arg0'26)) arg0'27)) arg0'28); (:) arg0'29 arg1'29 -> (case arg1'29 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'28 arg0'25)) arg0'26)) arg0'27)) arg0'28)) arg0'29); (:) arg0'30 arg1'30 -> (case arg1'30 of {[] -> (_5 arg0'25 arg0'26 arg0'27 arg0'28 arg0'29 arg0'30); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(43,1)-(49,13)|function prod_6"#)})})})})})})}))

prod_7 = (\ds'62 -> let { sh'30 = ((GHC.Num.+) sh'29); sh'29 = (GHC.Num.fromInteger 0) } in (case ds'62 of {[] -> sh'29; (:) arg0'31 arg1'31 -> (case arg1'31 of {[] -> (sh'30 arg0'31); (:) arg0'32 arg1'32 -> (case arg1'32 of {[] -> (((GHC.Num.+) (sh'30 arg0'31)) arg0'32); (:) arg0'33 arg1'33 -> (case arg1'33 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (sh'30 arg0'31)) arg0'32)) arg0'33); (:) arg0'34 arg1'34 -> (case arg1'34 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'30 arg0'31)) arg0'32)) arg0'33)) arg0'34); (:) arg0'35 arg1'35 -> (case arg1'35 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'30 arg0'31)) arg0'32)) arg0'33)) arg0'34)) arg0'35); (:) arg0'36 arg1'36 -> (case arg1'36 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'30 arg0'31)) arg0'32)) arg0'33)) arg0'34)) arg0'35)) arg0'36); (:) arg0'37 arg1'37 -> (case arg1'37 of {[] -> (_6 arg0'31 arg0'32 arg0'33 arg0'34 arg0'35 arg0'36 arg0'37); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(53,1)-(60,13)|function prod_7"#)})})})})})})})}))

prod_8 = (\ds'63 -> let { sh'32 = ((GHC.Num.+) sh'31); sh'31 = (GHC.Num.fromInteger 0) } in (case ds'63 of {[] -> sh'31; (:) arg0'38 arg1'38 -> (case arg1'38 of {[] -> (sh'32 arg0'38); (:) arg0'39 arg1'39 -> (case arg1'39 of {[] -> (((GHC.Num.+) (sh'32 arg0'38)) arg0'39); (:) arg0'40 arg1'40 -> (case arg1'40 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (sh'32 arg0'38)) arg0'39)) arg0'40); (:) arg0'41 arg1'41 -> (case arg1'41 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'32 arg0'38)) arg0'39)) arg0'40)) arg0'41); (:) arg0'42 arg1'42 -> (case arg1'42 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'32 arg0'38)) arg0'39)) arg0'40)) arg0'41)) arg0'42); (:) arg0'43 arg1'43 -> (case arg1'43 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'32 arg0'38)) arg0'39)) arg0'40)) arg0'41)) arg0'42)) arg0'43); (:) arg0'44 arg1'44 -> (case arg1'44 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'32 arg0'38)) arg0'39)) arg0'40)) arg0'41)) arg0'42)) arg0'43)) arg0'44); (:) arg0'45 arg1'45 -> (case arg1'45 of {[] -> (_7 arg0'38 arg0'39 arg0'40 arg0'41 arg0'42 arg0'43 arg0'44 arg0'45); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(64,1)-(72,13)|function prod_8"#)})})})})})})})})}))

prod_9 = (\ds'64 -> let { sh'34 = ((GHC.Num.+) sh'33); sh'33 = (GHC.Num.fromInteger 0) } in (case ds'64 of {[] -> sh'33; (:) arg0'46 arg1'46 -> (case arg1'46 of {[] -> (sh'34 arg0'46); (:) arg0'47 arg1'47 -> (case arg1'47 of {[] -> (((GHC.Num.+) (sh'34 arg0'46)) arg0'47); (:) arg0'48 arg1'48 -> (case arg1'48 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (sh'34 arg0'46)) arg0'47)) arg0'48); (:) arg0'49 arg1'49 -> (case arg1'49 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'34 arg0'46)) arg0'47)) arg0'48)) arg0'49); (:) arg0'50 arg1'50 -> (case arg1'50 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'34 arg0'46)) arg0'47)) arg0'48)) arg0'49)) arg0'50); (:) arg0'51 arg1'51 -> (case arg1'51 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'34 arg0'46)) arg0'47)) arg0'48)) arg0'49)) arg0'50)) arg0'51); (:) arg0'52 arg1'52 -> (case arg1'52 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'34 arg0'46)) arg0'47)) arg0'48)) arg0'49)) arg0'50)) arg0'51)) arg0'52); (:) arg0'53 arg1'53 -> (case arg1'53 of {[] -> (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (((GHC.Num.+) (sh'34 arg0'46)) arg0'47)) arg0'48)) arg0'49)) arg0'50)) arg0'51)) arg0'52)) arg0'53); (:) arg0'54 arg1'54 -> (case arg1'54 of {[] -> (_8 arg0'54 arg0'46 arg0'47 arg0'48 arg0'49 arg0'50 arg0'51 arg0'52 arg0'53); (_) -> (Control.Exception.Base.patError "/Volumes/Macintosh HD/Users/lptk/work/EPFL/DATA/git/alt/Squid-1.0/haskellopt/src/test/haskell/VectorsBench.hs:(76,1)-(85,13)|function prod_9"#)})})})})})})})})})}))
