<html><head><title>Squid: Home</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Lionel Parreaux (@lptk)" /><meta name="description" content="Squid ― type-safe metaprogramming for Scala" /><meta name="og:image" content="/squid/img/poster.png" /><meta name="og:title" content="Squid: Home" /><meta name="og:site_name" content="Squid" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Squid ― type-safe metaprogramming for Scala" /><link rel="icon" type="image/png" href="/squid/img/favicon.png" /><meta name="twitter:title" content="Squid: Home" /><meta name="twitter:image" content="img/poster.png" /><meta name="twitter:description" content="Squid ― type-safe metaprogramming for Scala" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/squid/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/squid/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/squid/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/squid/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/squid/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/squid/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/squid/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/squid/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/squid/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/squid/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/squid/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/squid/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/squid/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/squid/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/squid/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/squid/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/squid/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/squid/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/squid/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/squid/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/squid/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/squid/css/style.css" /><link rel="stylesheet" href="/squid/css/palette.css" /><link rel="stylesheet" href="/squid/css/codemirror.css" /></head><body><header id="site-header"><div class="navbar-wrapper"><div class="container"><div class="row"><div class="col-xs-6"><a href="/squid/" class="brand"><div class="icon-wrapper"><span>Squid</span></div></a></div><div class="col-xs-6"><nav class="text-right"><ul class=""><li><a href="https://github.com/epfldata/squid"><i class="fa fa-github"></i><span class="hidden-xs">GitHub</span></a></li><li><a href="/squid/reference"><i class="fa fa-file-text"></i><span class="hidden-xs">Documentation</span></a></li></ul></nav></div></div></div></div><div class="jumbotron"><div class="container"><h1 class="text-center">Squid ― type-safe metaprogramming for Scala</h1><h2></h2><p class="text-center"><a href="https://github.com/epfldata/squid" class="btn btn-outline-inverse">View on GitHub</a></p></div></div><div><ul class="horizontalNav">                   <li><a class=" active " href="/squid/home.html">Home</a></li>  <li><a class="" href="/squid/tutorial.html">Squid Tutorial</a></li>  <li><a class="" href="/squid/reference.html">Squid Reference</a></li> </ul></div></header><main id="site-main"><section class="use"><div class="container"><div id="content"><h1 id="squid--type-safe-metaprogramming-for-scala"><strong>Squid</strong> ― type-safe metaprogramming for Scala</h1>

<p><img src="https://img.shields.io/badge/stability-unstable-yellow.svg" alt="stability-unstable" />
<a href="https://gitter.im/epfldata-squid/Lobby?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/epfldata-squid/Lobby.svg" alt="Join the chat at https://gitter.im/epfldata-squid/Lobby" /></a></p>

<h2 id="introduction">Introduction</h2>

<p><strong>Squid</strong> (for the approximative contraction of <strong>Sc</strong>ala <strong>Qu</strong>ot<strong>ed</strong> <strong>D</strong>SLs)
is a <strong>metaprogramming</strong> framework 
that facilitates the <strong>type-safe</strong> manipulation of <strong>Scala programs</strong>.
Squid extends multi-stage programming capabilities with support for code inspection and code transformation. It has special support for 
<strong>library-defined optimizations</strong> <a href="#gpce17">[2]</a> and 
helps with the compilation of <strong>domain-specific languages</strong> (DSL) embedded in Scala <a href="#scala17">[1]</a>.
Squid uses <strong>advanced static typing</strong> techniques to prevent common metaprogramming errors, such as scope extrusion <a href="#popl18">[3]</a>.</p>

<p><a href="http://epfldata.github.io/squid/tutorial">Link to the Squid tutorial.</a></p>

<!-- TODO: give concrete application examples to pique curiosity/generate interest -->

<p><strong>Caution:</strong> Squid is still experimental, and the interfaces it exposes may slightly change in the future. This applies especially to the semi-internal interfaces used to implement intermediate representation backends (the <code class="highlighter-rouge">Base</code> trait and derived).</p>

<p><a name="early-example"></a></p>

<h2 id="an-early-example">An Early Example</h2>

<p>To give a quick taste of Squid’s unique mix of capabilities,
here is a basic (contrived!) example of program manipulation.
The full source code can be <a href="https://github.com/LPTK/Squid/blob/master/example/src/main/scala/example/PowOptim.scala">found here, in the example folder</a>.
Much more detailed explanations of each feature can be found in the <a href="http://epfldata.github.io/squid/tutorial">tutorial</a>.</p>

<p>The core of Squid’s frontend is its type- and scope-safe quasiquotation engine.
We can write program fragments, or <em>code values</em>, by using the <code class="highlighter-rouge">code</code> interpolator:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.io.StdIn</span>

<span class="k">val</span> <span class="n">c0</span> <span class="k">=</span> <span class="n">code</span><span class="s">"Some(StdIn.readDouble)"</span> <span class="c1">// resolves types and imports statically
</span>
<span class="n">println</span><span class="o">(</span><span class="n">c0</span><span class="o">)</span> <span class="c1">// code"scala.Some.apply[scala.Double](scala.io.StdIn.readDouble())"
</span></code></pre></div></div>

<p>We can then compose programs incrementally from smaller parts:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">c1</span><span class="k">:</span> <span class="kt">ClosedCode</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="n">code</span><span class="s">"$c0.get"</span>
<span class="c1">// ClosedCode[T], an alias for Code[T,Any], is the type of closed terms
</span>
<span class="n">println</span><span class="o">(</span><span class="n">c1</span><span class="o">)</span> <span class="c1">// code"scala.Some.apply[scala.Double](scala.io.StdIn.readDouble()).get"
</span>
<span class="c1">// A function that manipulates code fragments in context/scope C:
</span><span class="k">def</span> <span class="n">mkPow</span><span class="o">[</span><span class="kt">C</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">Code</span><span class="o">[</span><span class="kt">Double</span>,<span class="kt">C</span><span class="o">],</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Code</span><span class="o">[</span><span class="kt">Double</span>,<span class="kt">C</span><span class="o">])</span> <span class="k">=</span> <span class="n">code</span><span class="s">"Math.pow($b, $e)"</span>

<span class="k">val</span> <span class="n">c2</span><span class="k">:</span> <span class="kt">ClosedCode</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="n">mkPow</span><span class="o">(</span><span class="n">c1</span><span class="o">,</span> <span class="n">code</span><span class="s">"3"</span><span class="o">)</span>

<span class="c1">// method `=~=` tests for alpha-equivalence of code values:
</span><span class="n">assert</span><span class="o">(</span><span class="n">c2</span> <span class="o">=~=</span> <span class="n">code</span><span class="s">"java.lang.Math.pow(Some(StdIn.readDouble).get, 3.0)"</span><span class="o">)</span>
</code></pre></div></div>

<p>Now, let us define a <code class="highlighter-rouge">Math.pow</code> optimizer.
We’ll do a top-down rewriting until a fixed point is reached,
thanks to the <code class="highlighter-rouge">fix_topDown_rewrite</code> method:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">optPow</span><span class="o">[</span><span class="kt">T</span>,<span class="kt">C</span><span class="o">](</span><span class="n">pgrm</span><span class="k">:</span> <span class="kt">Code</span><span class="o">[</span><span class="kt">T</span>,<span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">Code</span><span class="o">[</span><span class="kt">T</span>,<span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="n">pgrm</span> <span class="n">fix_topDown_rewrite</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">code</span><span class="s">"Math.pow($x, 0.0)"</span>       <span class="k">=&gt;</span> <span class="n">code</span><span class="s">"1.0"</span>
  <span class="k">case</span> <span class="n">code</span><span class="s">"Math.pow($x, ${Const(d)})"</span> <span class="c1">// `Const` matches constants, so `d` has type Double
</span>    <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">isWhole</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">d</span> <span class="o">&amp;&amp;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">16</span>  <span class="k">=&gt;</span> <span class="n">code</span><span class="s">"Math.pow($x, ${Const(d-1)}) * $x"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And finally, let us build a compiler for fast power functions!
Given an integer <code class="highlighter-rouge">n</code>, we return a function that has been runtime-compiled to multiply any number with itself <code class="highlighter-rouge">n</code> times, using only plain multiplications:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">mkFastPow</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="nc">Double</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">powCode</span> <span class="k">=</span> <span class="n">code</span><span class="s">"${ (x: Variable[Double]) =&gt; mkPow(code"</span><span class="nc">$x</span><span class="s">", Const(n)) }"</span>
  <span class="c1">// ^ The line above lifts a function of type `(v: Variable[Double]) =&gt; Code[Double, v.Ctx]`
</span>  <span class="c1">//   into a program fragment of type `ClosedCode[Double =&gt; Double]`
</span>  <span class="k">val</span> <span class="n">powCodeOpt</span> <span class="k">=</span> <span class="n">optPow</span><span class="o">(</span><span class="n">powCode</span><span class="o">)</span> <span class="c1">// optimize our pow function
</span>  <span class="n">powCodeOpt</span><span class="o">.</span><span class="n">compile</span> <span class="c1">// produce efficient bytecode at runtime
</span><span class="o">}</span>
<span class="k">val</span> <span class="n">p4fast</span> <span class="k">=</span> <span class="n">mkFastPow</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span> <span class="c1">// equivalent to: `(x: Double) =&gt; 1.0 * x * x * x * x`
</span><span class="n">println</span><span class="o">(</span><span class="n">p4fast</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span> <span class="c1">// 3111696.0
</span></code></pre></div></div>

<p>This is just the beginning.
Squid has much more under the hood, including:
normalizing intermediate representations;
online optimization;
mixin program transformers;
cross-stage persistence;
automatic lifting and controlled inlining of library definitions;
painless compile-time optimization…
An overview of Squid’s features is given <a href="#overview">below</a>,
and a short example of some of them can be found
<a href="http://epfldata.github.io/squid/AdditionalExample.md">here</a>.</p>

<h2 id="getting-started">Getting Started</h2>

<p>Squid currently supports Scala versions <code class="highlighter-rouge">2.12.x</code> and <code class="highlighter-rouge">2.11.y</code> for <code class="highlighter-rouge">y &gt; 2</code>
(other versions might work as well, but have not been tested).</p>

<p>In your project, add the following to your <code class="highlighter-rouge">build.sbt</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">resolvers</span> <span class="o">+=</span> <span class="nc">Resolver</span><span class="o">.</span><span class="n">sonatypeRepo</span><span class="o">(</span><span class="s">"snapshots"</span><span class="o">)</span>

<span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">"ch.epfl.data"</span> <span class="o">%%</span> <span class="s">"squid"</span> <span class="o">%</span> <span class="s">"0.4.0-SNAPSHOT"</span>
</code></pre></div></div>

<p>Some features related to <a href="#qsr">library-defined optimizations</a> and <a href="#smacros">squid macros</a>, 
such as <code class="highlighter-rouge">@embed</code> and <code class="highlighter-rouge">@macroDef</code>, 
require the use of the <a href="https://docs.scala-lang.org/overviews/macros/paradise.html">macro-paradise</a>  plugin.
To use these features, add the following to your <code class="highlighter-rouge">build.sbt</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">paradiseVersion</span> <span class="k">=</span> <span class="s">"2.1.0"</span>

<span class="n">autoCompilerPlugins</span> <span class="o">:=</span> <span class="kc">true</span>

<span class="n">addCompilerPlugin</span><span class="o">(</span><span class="s">"org.scalamacros"</span> <span class="o">%</span> <span class="s">"paradise"</span> <span class="o">%</span> <span class="n">paradiseVersion</span> <span class="n">cross</span> <span class="nc">CrossVersion</span><span class="o">.</span><span class="n">full</span><span class="o">)</span>
</code></pre></div></div>

<p>In case you wish to use a more recent version of Squid that has not yet been published,
you’ll have to clone this repository
and publish Squid locally,
which can be done by executing the script in <code class="highlighter-rouge">bin/publishLocal.sh</code>.</p>

<p><a name="overview"></a></p>

<h2 id="overview-of-features">Overview of Features</h2>

<h3 id="squid-quasiquotes">Squid Quasiquotes</h3>

<p>Quasiquotes are the primitive tool that Squid provides to manipulate program fragments 
–– building, composing and decomposing them.
Quasiquotes are central to most aspects of program transformation in Squid.</p>

<p><a href="http://epfldata.github.io/squid/tutorial">You can find an in-depth tutorial about Squid quasiquotes here.</a></p>

<p><strong>Note:</strong>
In the original Squid papers <a href="#scala17">[1]</a> and <a href="#gpce17">[2]</a>,
we used <code class="highlighter-rouge">Code[T]</code> as the type of program fragments.
With the introduction of scope safety and our POPL 2018 paper <a href="#popl18">[3]</a>,
this type now takes an extra parameter, as in <code class="highlighter-rouge">Code[T,C]</code> where <code class="highlighter-rouge">C</code> represent the term’s context requirements.<br />
One cans still use type <code class="highlighter-rouge">OpenCode[T]</code> when context requirements are not important; this type has limited capabilities (no <code class="highlighter-rouge">run</code> or <code class="highlighter-rouge">compile</code>, for instance), but can be turned into a closed code type with method <code class="highlighter-rouge">unsafe_asClosedCode</code>.
On the other hand, <code class="highlighter-rouge">ClosedCode[T]</code> (a synonym for <code class="highlighter-rouge">Code[T,{}]</code>) is the type of closed program fragments.</p>

<h4 id="type-safe-code-manipulation">Type-Safe Code Manipulation</h4>

<p>Unlike the standard <a href="https://docs.scala-lang.org/overviews/quasiquotes/intro.html">Scala Reflection quasiquotes</a>,
Squid quasiquotes are statically-typed and hygienic, 
ensuring that manipulated programs remain well-scoped and well-typed 
and that variable bindings and other symbols do not get mixed up.
Still, Squid quasiquotes support a flexible pattern-matching syntax 
and facilities to traverse programs recursively while applying transformations.</p>

<p>While Squid quasiquotes focus on expressions (not definitions), Squid also provides a way to <em>embed</em> arbitrary class and object definitions so that their methods can be inlined effortlessly, at the discretion of the metaprogrammer.</p>

<p>As a quick reference for Squid users, 
we provide a <a href="https://github.com/epfldata/squid/tree/master/doc/reference/Quasiquotes.md">cheat sheet</a> that summarizes the features of Squid quasiquotes. Also see the <a href="http://epfldata.github.io/squid/tutorial">quasiquotes tutorial</a>.</p>

<p><a name="msp"></a>
<a name="qsr"></a></p>

<h3 id="multi-stage-programming-and-quoted-staged-rewriting">Multi-Stage Programming and Quoted Staged Rewriting</h3>

<p>Squid fully support the multi-staged programming paradigm (MSP), 
allowing the composition and evaluation of program fragments at runtime
(via runtime compilation or reflective interpretation).</p>

<p>In addition, since Squid provides type-safe code inspection capabilities
(a novelty in the field of statically-typed staging),
it can be used to achieve quoted staged rewriting (QSR) <a href="#gpce17">[2]</a>,
an approach to program optimization that mixes the advantages of user-defined rewrite rules, strategic program transformation and MSP.</p>

<p><a name="ldo"></a></p>

<h3 id="library-defined-optimizations">Library-Defined Optimizations</h3>

<p>Squid provides tools to create <em>static optimizers</em>, 
which are used to optimize <em>at compile time</em> delimited portions of a user’s codebase.
Together with quoted staged rewriting, 
this capability allows for quite flexible and safe library-defined optimizations <a href="#gpce17">[2]</a>.</p>

<p><a href="https://github.com/epfldata/squid/tree/master/doc/Transformers.md#static-optimizers">Click here to learn more about static optimizers.</a></p>

<p><a name="transformers"></a></p>

<h3 id="program-transformation-support">Program Transformation Support</h3>

<p>Squid supports the definition and composition of custom program transformers and transformation strategies.
This is achieved via Scala mixin-composition and quasiquote-based rewriting declarations.
Squid transformers are type-preserving, 
and they make sure that transformed programs remain well-typed and well-scoped.</p>

<p><a href="https://github.com/epfldata/squid/tree/master/doc/Transformers.md">Click here to learn more about Squid transformers.</a></p>

<p><a name="irs"></a></p>

<h3 id="intermediate-representations">Intermediate Representations</h3>

<p>Squid quasiquotes, and Squid’s infrastructure in general, are unique 
in that they are generic in the actual intermediate representation (IR)
used to encode program fragments.
Custom IRs can be implemented and plugged into Squid to gain the high-level, type-safe features offered by Squid. 
This is done by implementing Squid’s object algebra interface <a href="#scala17">[1]</a>.</p>

<p>[Click here to learn more about Squid intermediate representations.](lso see the <a href="https://github.com/epfldata/squid/tree/master/doc/Intermediate_Representations.md">quasiquotes tutorial</a></p>

<p><a name="smacros"></a></p>

<h3 id="squid-macros">Squid Macros</h3>

<p>Squid macros are an experimental type-safe alternative to legacy scala-reflect macros, based on Squid’s infrastructure.
The current implementation is a very rough prototype that should not yet be relied upon.</p>

<p>As an example, here is <a href="#early-example">the short program transformation</a> 
showed at the beginning of this document,
rewritten as a Squid macro:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@macroDef</span><span class="o">(</span><span class="nc">Embedding</span><span class="o">)</span>
<span class="k">def</span> <span class="n">myMacro</span><span class="o">(</span><span class="n">pgrm0</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// in this scope, `pgrm0` has type `Code[Double]`
</span>  <span class="k">val</span> <span class="n">pgrm1</span> <span class="k">=</span> <span class="n">pgrm0</span> <span class="n">transformWith</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Lowering</span><span class="o">(</span><span class="ss">'MyPhase)</span> <span class="k">with</span> <span class="nc">BottomUpTransformer</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">pgrm2</span> <span class="k">=</span> <span class="n">pgrm1</span> <span class="n">rewrite</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">code</span><span class="s">"($xs:List[$t]).::($x).head"</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">code</span><span class="s">"(${Const(n)}:Int) + (${Const(m)}:Int)"</span> <span class="k">=&gt;</span> <span class="nc">Const</span><span class="o">(</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">pgrm2</span>
<span class="o">}</span>

<span class="c1">// the following should appear in a different project:
</span><span class="n">myMacro</span><span class="o">(</span><span class="nc">Test</span><span class="o">.</span><span class="n">foo</span><span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// expands into `2.toDouble`
</span></code></pre></div></div>

<p>(Note: the <code class="highlighter-rouge">macroDef</code> feature currently lives in experimental branch <code class="highlighter-rouge">squid-macros</code>.)</p>

<h2 id="applications-of-squid">Applications of Squid</h2>

<p>Squid is still quite new and “bleeding edge”.
See the <a href="example/src/main/scala/">examples folder</a> for some example uses.
A little query compiler built with Squid can be found <a href="https://github.com/epfldata/sc-public/tree/master/relation-dsl-squid">here</a>. Another LINQ-inspired query engine build with Squid can be found <a href="https://github.com/epfldata/dbstage">here</a>.
We also built a small staged linear algebra library prototype <a href="#ecoop19">[4]</a>,
to be released soon.</p>

<h2 id="publications">Publications</h2>

<p><a name="scala17">[1]</a>: 
Lionel Parreaux, Amir Shaikhha, and Christoph E. Koch. 2017.
<a href="https://conf.researchr.org/event/scala-2017/scala-2017-papers-squid-type-safe-hygienic-and-reusable-quasiquotes">Squid: Type-Safe, Hygienic, and Reusable Quasiquotes</a>. In Proceedings of the 2017 8th ACM SIGPLAN Symposium on Scala (SCALA 2017).
(Get the paper <a href="https://infoscience.epfl.ch/record/231700">here</a>.)
<!-- https://doi.org/10.1145/3136000.3136005 --></p>

<p><a name="gpce17">[2]</a>: 
Lionel Parreaux, Amir Shaikhha, and Christoph E. Koch. 2017.
<a href="https://conf.researchr.org/event/gpce-2017/gpce-2017-gpce-2017-staged-rewriting-a-practical-approach-to-library-defined-optimization">Quoted Staged Rewriting: a Practical Approach to Library-Defined Optimizations</a>.
In Proceedings of the 2017 ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences (GPCE 2017). <strong>Best Paper Award.</strong>
(Get the paper <a href="https://infoscience.epfl.ch/record/231076">here</a>.)</p>

<p><a name="popl18">[3]</a>: 
Lionel Parreaux, Antoine Voizard, Amir Shaikhha, and Christoph E. Koch. 2018.
<a href="https://popl18.sigplan.org/event/popl-2018-papers-unifying-analytic-and-statically-typed-quasiquotes">Unifying Analytic and Statically-Typed Quasiquotes</a>.
In Proceedings of the ACM on Programming Languages (POPL 2018).
(Get the paper <a href="https://infoscience.epfl.ch/record/232427">here</a>.)</p>

<p><a name="ecoop19">[4]</a>: 
Amir Shaikhha, Lionel Parreaux. 2019.
<a href="https://2019.ecoop.org/details/ecoop-2019-papers/5/Finally-a-Polymorphic-Linear-Algebra-Language">Finally, a Polymorphic Linear Algebra Language</a>.
In 33rd European Conference on Object-Oriented Programming (ECOOP 2019).
(Get the paper <a href="https://infoscience.epfl.ch/record/266001">here</a>.)</p>

</div></div></section><section class="technologies"><div class="container"><div class="row"></div></div></section></main><footer id="site-footer"><div class="container"><div class="row"><div class="col-xs-6"><p>Squid is designed and developed by <a href="https://data.epfl.ch/" target="_blank">Lionel Parreaux (@lptk)</a></p></div><div class="col-xs-6"><p class="text-right"><a href="https://github.com/epfldata/squid"><span class="fa fa-github"></span>View on GitHub</a></p></div></div><div class="row"><div class="col-xs-6"><p>Website built with <a href="https://47deg.github.io/sbt-microsites/" target="_blank">Sbt-microsites</a> - © 2016 <a href="https://www.47deg.com/" target="_blank">47 Degrees</a></p></div></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/squid/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script>((window.gitter = {}).chat = {}).options = {
room: 'epfldata-squid/Lobby'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script></body></html>